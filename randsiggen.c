/******************************************************************************
*                                                                             *
* FILE NAME: randsiggen.c                                                     *
*                                                                             *
* PURPOSE: Batch generate large quantities of random signals from a given     *
*          peptide on behalf of seqmodlib and an implementation of a trie     *
*          data structure to store them.                                      *
*                                                                             *
* EXTERNAL REFERENCES: SFMT library, GNU libGSL                               *
*                                                                             *
******************************************************************************/

/* Include preinstalled libraries */
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <time.h>
#include <math.h>
#include <Python.h>
/* Include GNU libGSL */
#include "PATH TO libGSL" 
/* Include SFMT */
#include "PATH TO SMFT"

/* Docstrings */
static char module_docstring[] = "Generate random signals.";
static char random_signal_docstring[] = "Generate random signals.";

/* Prototypes */

/*
 *
 * source_count struct
 *
 * Used by trie node struct to track number of times proteins yielded the
 * node's signal.
 *
 * protein is the string representing the source protein.
 *
 * count is the number of times that protein has yielded the node's signal.
 *
 */

typedef struct
{
    char *protein;
    long count;
} source_count;

/*
 *
 * signal_trie struc
 *
 * An implementation of the atomic element of a trie (prefix tree) structure to
 * store large numbers of signals, and for each of these signals to track the
 * number of times they were generated by particular souce proteins. The trie's
 * root node is null -- indicated by having its amino acid set to 'z' --
 * representing an empty signal. All descendant nodes identify themselves by a
 * letter representing an amino acid and an integer for the their position in
 * Edman cycle observation space. A node represents the signal composed by
 * concatenating the amino acids and their positions transversed to reach it,
 * itself included. Each node contains an array of pointers to further sequence
 * members; each node is likewise pointed to by its ancestor. To count the
 * number of times a protein generated the signal represented by the node, each
 * node contains an array of source_count structs mapping the source protein of
 * its signal to an integer representing the number its signals from that
 * protein.
 *
 * position is the index for the location of the acid in Edman cycle            
 * observation space.
 *
 * acid is the amino acid observation of the node.
 *
 * descendants is a dynamic array of pointers to descendant nodes.
 *
 * num_descendants tracks the number of descendant nodes in the dynamic
 * descendants array.
 *
 * d_size tracks the size of descendants array.
 *
 * counts is the a dynamic array of source_count structs tracking how often
 * each protein has generated the signal ending in this node.
 *
 * c_size tracks the size of counts array.
 *
 * num_counts tracks the number of source_count structs in the dynamic counts
 * array.
 *
 */
struct node
{
    int position;
    char acid;
    struct node *descendants;
    long num_descendants;
    long d_size;
    source_count *counts;
    int num_counts;
    int c_size;
};
typedef struct node node;

/*
 *
 * acid observation struct
 *
 * Stores both the initial and observed positions of a labeled acid.
 * 
 * signal_block.i_position is the initial position of a labeled acid in its
 * peptide. Position index starts at 1, i.e. position 1 is the N-terminus acid
 * in the peptide. The initial position in peptide sequence space maps to the
 * same position in Edman cycle observation space under ideal conditions.
 *
 * signal_block.o_position is the observed position of a labeled acid in Edman
 * cycle observation space. Position index starts at 1, i.e. position 1 is
 * observing a drop in luminosity corresponding to this acid after the first
 * Edman cycle. Position index g represents observation of a drop in luminosity
 * after g Edman cycles. The special case of position being -1 is if the acid
 * is in the peptide after the first amino acid hybridized to the substrate;
 * acids in the tail are assumed to be unaccessable to Edman chemistry.
 *
 * signal_block.i_acid is the identity of the labeled acid to be observed. Each
 * acid is regarded as uniquely distringuishible; to simulate multiple acids
 * being labeled with identical fluors, use the seqmodlib function
 * homogenize().
 *
 * signal_block.o_acid is the acid observed via luminosity drop of its
 * corresponding fluor color. Setting o_acid to 'x' indicates this acid's
 * luminosity drop was not observed at all. The position remaining at -1 for
 * the observed acid means the acid is in the tail and their fluor is still
 * active.
 *
 */
typedef struct
{
    int i_position;
    char i_acid;
    int o_position;
    char o_acid;
} acid_observation;

/******************************************************************************
*                                                                             *
* FUNCTION NAME:    FindNode                                                  *
*                                                                             *
*     ARGUMENT LIST:                                                          *
*                                                                             *
*     Argument          Type                IO  Description                   *
*     ----------------  ------------------  --  ----------------------------- *
*     search_node       node *              I   The node amongst whose        *
*                                               descendants to search for a   *
*                                               node corresponding to         *
*                                               acid_observation's observed   *
*                                               position and acid.            *
*     observation       acid_observation *  I   The acid observation for      *
*                                               observed values are searched  *
*                                               for amongst search_node's     *
*                                               descendants.                  *
*                                                                             *
*     RETURN VALUE:                                                           *
*                                                                             *
*     Pointer to the descendant node corresponding to acid_observation's      *
*     observed values, or NULL if not present.                                *
*                                                                             *
******************************************************************************/
node *FindNode(node* search_node, acid_observation *descendant)
{
    node *d_iter;    /* Points to each descendant in succession. */
    const node *last = search_node->descendants + search_node->num_descendants;
    for (d_iter  = search_node->descendants; d_iter < last; d_iter++)
    {
        if (d_iter->position == descendant->o_position &&
            d_iter->acid == descendant->o_acid)
        {
            return d_iter;
        }
    }
    return NULL;
}

/******************************************************************************
*                                                                             *
* FUNCTION NAME:    AddDescendant                                             *
*                                                                             *
*     ARGUMENT LIST:                                                          *
*                                                                             *
*     Argument          Type                IO  Description                   *
*     ----------------  ------------------  --  ----------------------------- *
*     target_node       node *              IO  The node to which to add the  *
*                                               descendant node. If the node  *
*                                               for the observation already   *
*                                               exists amongst target_node's  *
*                                               descendants, do nothing.      *
*     descendant        acid_observation *  I   Add the node corresponding to *
*                                               this observation. If this     *
*                                               points to an array of         *
*                                               acid_observations, it uses    *
*                                               the first one.                *
*                                                                             *
*     RETURN VALUE:                                                           *
*                                                                             *
*     Pointer to the descendant node.                                         *
*                                                                             *
******************************************************************************/
node *AddDescendant(node *target_node, acid_observation *descendant)
{
    node *searched = FindNode(target_node, descendant);
    if (searched != NULL)
    {
        return searched;
    }
    /*
     *
     * There is no descendant node corresponding to the given
     * acid_observation. Create a new node.
     *
     */
    const long init_d_size = 10L;    /* Initial size of descendants array. */
    const int init_c_size = 5;    /* Initial size of counts array. */
    const long doubling_threshold = 80L;    /* If d_dize <= this threshold, ok
                                               to double array. Otherwise only
                                               increase by the threshold. */
    if (target_node->num_descendants == target_node->d_size)
    {
        target_node->d_size = ((long) (
                        (target_node->d_size <= doubling_threshold) ?
                                    2 * target_node->d_size :
                                    target_node->d_size + doubling_threshold));
        target_node->descendants = realloc(target_node->descendants,
                                           target_node->d_size * sizeof(node));
    }
    node *new_node = target_node->descendants + target_node->num_descendants;
    new_node->position = descendant->o_position;
    new_node->acid = descendant->o_acid;
    new_node->descendants = malloc(sizeof(node) * init_d_size);
    new_node->num_descendants = 0L;
    new_node->d_size = init_d_size;
    new_node->counts = malloc(sizeof(source_count) * init_c_size);
    new_node->num_counts = 0;
    new_node->c_size = init_c_size;
    ++(target_node->num_descendants);
    return new_node;
}

/******************************************************************************
*                                                                             *
* FUNCTION NAME:    FindSource                                                *
*                                                                             *
*     ARGUMENT LIST:                                                          *
*                                                                             *
*     Argument        Type                IO  Description                     *
*     --------------  ------------------  --  ------------------------------- *
*     target_node     node *              I   The node amongst whose          *
*                                             source_counts to search for a   *
*                                             node corresponding to protein.  *
*     protein         char *              I   The protein for whose           *
*                                             source_count to search.         *
*                                                                             *
*     RETURN VALUE:                                                           *
*                                                                             *
*     source_count corresponding to protein, or NULL is not found.            *
*                                                                             *
******************************************************************************/
source_count *FindSource(node *target_node, char *protein)
{
    source_count *s_iter;    /* Points to each source_count in succession. */
    const source_count *last = (target_node->counts + target_node->num_counts);
    for (s_iter  = target_node->counts; s_iter < last; s_iter++)
    {
        if (strcmp(s_iter->protein, protein) == 0)
            return s_iter;
    }
    return NULL;
}

/******************************************************************************
*                                                                             *
* FUNCTION NAME:    AddSource                                                 *
*                                                                             *
*     ARGUMENT LIST:                                                          *
*                                                                             *
*     Argument        Type                IO  Description                     *
*     --------------  ------------------  --  ------------------------------- *
*     target_node     node *              IO  The node to which to add the    *
*                                             source_count for protein. It it *
*                                             already exists, do nothing.     *
*     protein         char *              I   Add source_count for this       *
*                                             protein. Initialize count to 0. *
*                                                                             *
*     RETURN VALUE:                                                           *
*                                                                             *
*     source_count corresponding to protein.                                  *
*                                                                             *
******************************************************************************/
source_count *AddSource(node *target_node, char *protein)
{
    source_count *searched = FindSource(target_node, protein);
    if (searched != NULL)
        return searched;
    else
    {
        if (target_node->num_counts == target_node->c_size)
        {
            const int doubling_threshold = 80;    /* If d_dize <= this
                                                     threshold, ok to double
                                                     array. Otherwise only
                                                     increase by threshold. */
            target_node->c_size = (
                              (target_node->num_counts <= doubling_threshold) ?
                               target_node->c_size * 2 :
                               target_node->c_size + doubling_threshold);
            target_node->counts = (realloc(target_node->counts,
                                  target_node->c_size * sizeof(source_count)));
        }
        source_count *new_count = (target_node->counts +
                                   target_node->num_counts);
        new_count->protein = malloc(sizeof(char) * (strlen(protein) + 1));
        strcpy(new_count->protein, protein);
        new_count->count = 0L;
        ++(target_node->num_counts);
        return new_count;
    }
}

/******************************************************************************
*                                                                             *
* FUNCTION NAME:    IncrementSource                                           *
*                                                                             *
*     ARGUMENT LIST:                                                          *
*                                                                             *
*     Argument        Type                IO  Description                     *
*     --------------  ------------------  --  ------------------------------- *
*     target_node     node *              IO  The node whose source_count for *
*                                             protein should be incremented   *
*                                             by one. If the source count for *
*                                             protein does not exist, create  *
*                                             it.                             *
*     protein         char *              I   Source protein to increment.    *
*                                                                             *
*                                                                             *
*     RETURN VALUE:                                                           *
*                                                                             *
*     source_count which was incremented.                                     *
*                                                                             *
******************************************************************************/
source_count *IncrementSource(node *target_node, char *protein)
{
    source_count *searched = FindSource(target_node, protein);
    if (searched != NULL)
    {
        ++(searched->count);
        return searched;
    }
    else
    {
        source_count *new_s = AddSource(target_node, protein);
        ++(new_s->count);
        return new_s;
    }
}

/******************************************************************************
*                                                                             *
* FUNCTION NAME:    AddSignal                                                 *
*                                                                             *
*     ARGUMENT LIST:                                                          *
*                                                                             *
*     Argument        Type                 IO  Description                    *
*     --------------  -------------------  --  ------------------------------ *
*     target_node     node *               IO  The node to which to add a     *
*                                              signal. If the signal maps to  *
*                                              this node, its source_count    *
*                                              will be modified. If the       *
*                                              signal maps to a descendant    *
*                                              node, this function will be    *
*                                              called recursively.            *
*     signal          acid_observation **  I   Pointers to sequence of        *
*                                              nonempty observations whose    *
*                                              observed acids and positions   *
*                                              encode the signal.             *
*     signal_size     int                  I   Length of signal: number of    *
*                                              its acid_observations structs  *
*     protein         char *               I   Name of source protein for     *
*                                              signal.                        *
*                                                                             *
*     RETURN VALUE:                                                           *
*                                                                             *
*     Node which corresponds to the signal unless signal_size is 0, in which  *
*     case return NULL.                                                       *
*                                                                             *
******************************************************************************/
node *AddSignal(node *target_node, acid_observation **signal, int signal_size,
                char *protein)
{
    /* Do not add empty signals. */
    if (signal_size == 0)
        return NULL;
    else if (target_node->acid == 'z')
    {
        node *new_d = AddDescendant(target_node, *signal);
        return AddSignal(new_d, signal, signal_size, protein);
    }
    else if (signal_size == 1)
    {
        IncrementSource(target_node, protein);
        return target_node;
    }
    else
    {
        node *new_d = AddDescendant(target_node, *(signal + 1));
        node *r = AddSignal(new_d, signal + 1, signal_size - 1, protein);
        return r;
    }
}

/******************************************************************************
*                                                                             *
* FUNCTION NAME:    CompareAcidObservations                                   *
*                                                                             *
*     ARGUMENT LIST:                                                          *
*                                                                             *
*     Argument       Type              IO  Description                        *
*     -----------  ------------------  --  ---------------------------------  *
*     a            acid_observation *  I   acid_observation struct to compare *
*     b            acid_observation *  I   acid_observation struct to compare *
*                                                                             *
*     RETURN VALUE:                                                           *
*                                                                             *
*     -1 if a is observed on an Edman cycle after b or if a is on the same    *
*         Edman cycle and is alphabetically after b                           *
*     0 if a is observed on the same Edman cycle as b and has the same acid   *
*         as b                                                                *
*     1 if a is observed on an Edman cycle before b or if a is on the same    *
*         Edman cycle and is alphabetically before b                          *
*                                                                             *
******************************************************************************/
int CompareAcidObservations(acid_observation *a, acid_observation *b)
{
    /* Position has priority in sorting. */
    if (a->o_position > b->o_position)
        return 1;
    else if (a->o_position < b->o_position)
        return -1;
    /* Position is the same; compare acids. */
    else if (a->o_acid > b->o_acid)
        return 1;
    else if (a->o_acid < b->o_acid)
        return -1;
    else
        return 0;
}

/******************************************************************************
*                                                                             *
* FUNCTION NAME:    PackagePyTrie                                             *
*                                                                             *
*     ARGUMENT LIST:                                                          *
*                                                                             *
*     Argument        Type                IO  Description                     *
*     --------------  ------------------  --  ------------------------------- *
*     target_node     node *              IO  Package this node's             *
*                                             descendants. Delete all nodes   *
*                                             packaged and deallocate all     * 
*                                             associated memory.              *
*     prefix          node ***            IO  Pointer to array of pointers to *
*                                             all prior nodes including the   *
*                                             'z' root node.                  *
*     prefix_length   int                 I   Number of nodes in prefix.      *
*     prefix_alloc    int *               IO  Amount of memory allocated for  *
*                                             prefix in numbers of nodes.     *
*     return_trie     PyObject *          IO  The instance of the Python      *
*                                             seqmodlibMP.SignalTrie to       *
*                                             package into.                   *
*                                                                             *
*     RETURN VALUE:                                                           *
*                                                                             *
*     None.                                                                   *
*                                                                             *
******************************************************************************/
void PackagePyTrie(node *target_node, node ***prefix, int prefix_length,
                   int *prefix_alloc, PyObject *return_trie)
{
    /*
     *
     * For reference.
     *
     * typedef struct
     * {
     *     const int position;
     *     const char acid;
     *     node *descendants;
     *     long num_descendants;
     *     long d_size;
     *     source_count *counts;
     *     int num_counts;
     *     int c_size;
     * } node;
     *
     */
    /* Declare generic loop counter. */
    int i;

    /* Increase prefix array size if necessary. */
    const int doubling_threshold = 80;
    /*if (prefix_length >= *prefix_alloc - 5)*/
    if (prefix_length == *prefix_alloc)
    {
        *prefix_alloc = (*prefix_alloc < doubling_threshold ?
                         *prefix_alloc * 2 :
                         *prefix_alloc + doubling_threshold);
        *prefix = realloc(*prefix, *prefix_alloc * sizeof(node *));
    }
    /* Add target_node to prefix array. Prefix now includes target_node. */
    *(*prefix + prefix_length) = target_node;
    ++prefix_length;
    /* Iterate through all descendants and recurse. */
    node *iter;
    node *last = target_node->descendants + target_node->num_descendants;
    for (iter = target_node->descendants; iter < last; iter++)
        PackagePyTrie(iter, prefix, prefix_length, prefix_alloc, return_trie);
    /* If this node has a source_count, package it. */
    if (target_node->num_counts > 0)
    {
        /* Create tuple from prefix. */
        node **p_iter;
        /*
         *
         * Note that the following lines take into account that prefix_length
         * includes root.
         *
         */
        node **p_last = *prefix + prefix_length;
        PyTupleObject *package_signal = ((PyTupleObject *)
                                         PyTuple_New(prefix_length - 1));
        for (p_iter = *prefix + 1, i = 0; p_iter < p_last; p_iter++, i++)
        {
            /*PyObject *temptuple = Py_BuildValue("(i, c)", (*p_iter)->position, (*p_iter)->acid);
            Py_INCREF(temptuple);
            PyTuple_SET_ITEM(package_signal, i, temptuple);*/
            PyTuple_SET_ITEM(package_signal, i,
                Py_BuildValue("(i, c)", (*p_iter)->position, (*p_iter)->acid));
        }
        /* {protein: count} */
        PyDictObject *package_dictionary = (PyDictObject *) PyDict_New();
        source_count *c_iter;
        source_count *c_last = target_node->counts + target_node->num_counts;
        for (c_iter = target_node->counts; c_iter < c_last; c_iter++)
        {
            /*
             *
             * For reference.
             *
             * typedef struct
             * {
             *    char *protein;
             *    long count;
             * } source_count;
             *
             */
            PyStringObject *pt = ((PyStringObject *)
                                  PyString_FromString(c_iter->protein));
            free(c_iter->protein);
            PyIntObject *ct = (PyIntObject *) PyInt_FromLong(c_iter->count);
            PyDict_SetItem((PyObject *) package_dictionary, (PyObject *) pt,
                           (PyObject *)ct);
            Py_DECREF(pt);
            Py_DECREF(ct);
        }
        /* Tuple and signal_count ready for packaging. Call graft function. */
        /*PyTupleObject *a = Py_BuildValue("(O, O, O)",
                              return_trie, package_signal, package_dictionary);*/

        PyObject_CallMethod(return_trie, "graft", "(O, O)", package_signal,
                            package_dictionary);
        Py_DECREF(return_trie);    /* PyObject_CallMethod returns a new
                                      reference to the result of the call,
                                      which in this case is returning
                                      return_trie. This increases references to
                                      return_trie causing memory leaks.*/

        /* DECREF */
        Py_DECREF(package_signal);
        Py_DECREF(package_dictionary);
        /*Py_DECREF(a);*/
    }
    /*
     *
     * This node is done. Deallocate all related memory. source_count->protein
     * free above.
     *
     */
    free(target_node->descendants);
    free(target_node->counts);

    return;
}

/******************************************************************************
*                                                                             *
* FUNCTION NAME:    RandomSignal                                              *
*                                                                             *
*     ARGUMENT LIST:                                                          *
*                                                                             *
*     Argument       Type              IO  Description                        *
*     -------------  ----------------  --  ---------------------------------  *
*     self           PyObject *        I   reference to randsiggen module     *
*                                          module object for module level     *
*                                          functions                          *
*     args           PyObject *        I   pointer to Python tuple object     *
*                                          containing arguments passed by     *
*                                          Python as described below          *
*                                                                             *
*     args tuple     = (peptide, protein, p, b, u, windows, sample_size,      *
*                       random_seed, return_trie)                             *
*     -------------  ----------------  --  ---------------------------------- *
*     peptide        PyTupleObject *   I   The signal source peptide          *
*                                          represented as a Python tuple      *
*                                          ('head string', 'tail string'),    *
*                                          where head string is a Python      *
*                                          string representing the amino acid *
*                                          sequence ahead of the first amino  *
*                                          acid attached to the substrate,    *
*                                          and tail string is the sequence of *
*                                          amino acids after and including    *
*                                          that attaching acid. seqmodlib     *
*                                          attach generates such pair tuples. *
*     protein        PyStringObject *  IO  Name of the source protein.        *
*     p              PyFloatObject *   I   Probability of an Edman reaction   *
*                                          succeeding. All Edman reactions    *
*                                          are modelled as independent        *
*                                          Bernoulli variables. p must be a   *
*                                          Python floating point number in    *
*                                          [0, 1] inclusive.                  *
*     b              PyFloatObject *   I   Photobleaching survival constant.  *
*                                          Photobleaching is modeled as an    *
*                                          exponential survival function      *
*                                          s(k) = e^-bk, modelling the        *
*                                          probability of a fluor surviving k *
*                                          laser exposures. b must be a       *
*                                          Python floating point number       *
*                                          greater than or equal to 0.        *
*     u              PyFloatObject *   I   Probability of a fluor being       *
*                                          photobleached or unattached or     *
*                                          otherwise nonfunctional prior to   *
*                                          the experimental cycle and hence   *
*                                          unobservable to begin with.        *
*                                          Probabilities of each fluor being  *
*                                          unobservable are independent. u    *
*                                          must be a Python floating point    *
*                                          number in [0, 1] inclusive.        *
*     windows        PyDictObject *    I   Number of Edman cycles to simulate *
*                                          for each fluor color. windows must *
*                                          be a Python dictionary of the form *
*                                          {acid: number of cycles} where     *
*                                          keys are single-letter Python      *
*                                          strings representing the labeled   *
*                                          acids, and values are the number   *
*                                          cycles for which that acid is      *
*                                          observed represented as a Python   *
*                                          integer object. Currently,         *
*                                          RandomSignal does not implement    *
*                                          any differences in observation     *
*                                          intervals for multiple acids, but  *
*                                          merely applies the dictionary's    *
*                                          first cycle value uniformly to all *
*                                          colors.                            *
*     sample_size    PyIntObject  *    I   Python integer object indicating   *
*                                          how many random signals to         *
*                                          generate for the given peptide.    *
*     random_seed    PyIntObject  *    I   Python integer object used to seed *
*                                          the random number generator used   *
*                                          by RandomSignal. This is used to   *
*                                          make sure the random numbers       *
*                                          generated by multiple processes    *
*                                          avoid seed duplicates.             *
*     return_trie    PyClassObject *   I   The root node instance of          *
*                                          seqmodlibMP.SignalTrie.            *
*                                                                             *
*     RETURN VALUE:                                                           *
*                                                                             *
*     seqmodlib's SignalTrie representation of all signals generated.         *
*                                                                             *
******************************************************************************/
static PyObject *RandomSignal(PyObject *self, PyObject *args)
{
    /*************************************************************************/
    /* Declare loop counters and auxilliary variables. ***********************/
    long s, i, j;    /* Loop counters. */
    float random_point;    /* Stores random point to be mapped to outcomes. */
    float accumulator;    /* Stores cumulative probabilities when mapping via
                             cumulative distributions experimental outcomes
                             determined by random_point. */
    int exposures;    /* Used to track how many exposures hit fluor before it
                         cleaves. */
    
    /*************************************************************************/
    /* Declare variables to store passed arguments. **************************/

    /*
     *
     * Store the peptide head and tail as strings.                   
     * Do not modify these strings as they are objects in the Python universe
     * that the interpreter claims as its own. Python docs call this a
     * /borrowed/ reference, but do not thoroughly explain the mechanism behind
     * it.
     *
     */
    PyTupleObject *peptide;
    char *head, *tail;

    /* Store the name of the source protein as a string. */
    PyStringObject *protein;
    char *protein_string;

    /* Variables to store experimental paramters. */
    const float p, b, u;
    /*
     *
     * Window cycle dictionary. Use the first value to set a uniform number of
     * cycles for all fluor colors. Store the set of all amino acids to observe
     * as a character array. This array will be filled during unpacking.
     *
     */
    const PyDictObject *windows;
    long cycles;
    char *acids;
    char *acids_iterator;    /* Used to iterate over acids array. */

    /* How many samples to generate for this peptide. */
    const long sample_size;

    /*
     *
     * Integer passed from python to be combined with high resolution timers to
     * ensure quality random seed for the Merseinne Twister random number
     * generator.
     *
     */
    const long random_seed;

    /* The C SignalTrie root. */
    node *signal_trie;

    /* Pointers to seqmodlibMP.SignalTrie root node. */
    const PyClassObject *return_trie;

    /*************************************************************************/
    /* Main working arrays for generating signals. ***************************/

    /*
     *
     * Arrays of acid_observation structs to (1) persistently store the initial
     * peptide fluor configuration -- observations_template and (2) keep track
     * of luminosity drops throughout the simulation for each sample --
     * observations. The template is initialized after the Python args tuple
     * has been parsed and both the peptide sequence and the set of labeling
     * fluors is known. The simulation working array observations is reset
     * before simulating each sample. num_head_ops indicates how many of the
     * first observation structs are from the head of the peptide. num_obs is
     * the total number of observations.
     *
     */
    acid_observation *observations;
    acid_observation *observations_template;
    acid_observation *obs_iter;
    acid_observation *obs_template_iter;
    int num_obs;
    int num_head_obs;

    /* Array of pointers to nonempty observations. */
    long nonempty;    /* Number of nonempty acid_observations after
                         simulation. */
    const acid_observation **nonempty_observations;
    acid_observation **nonempty_iter;
    
    /*************************************************************************/
    /* Parse args tuple. *****************************************************/
    PyArg_ParseTuple(args, "OOfffOllO", &peptide, &protein, &p, &b, &u,
                     &windows, &sample_size, &random_seed, &return_trie);
    /* Unpack peptide tuple into head and tail. */
    Py_INCREF(peptide);
    Py_INCREF(protein);
    Py_INCREF(windows);
    Py_INCREF(return_trie);
    PyStringObject *h = (PyStringObject *) PyTuple_GET_ITEM(peptide, 0);
    Py_INCREF(h);
    PyStringObject *t = (PyStringObject *) PyTuple_GET_ITEM(peptide, 1);
    Py_INCREF(t);
    head = malloc((PyString_Size((PyObject *) h) + 1) * sizeof(char));
    tail = malloc((PyString_Size((PyObject *) t) + 1) * sizeof(char));
    strcpy(head, PyString_AsString((PyObject *) h));    /* Use strcpy to avoid
                                                           issues with borrowed
                                                           references. */
    strcpy(tail, PyString_AsString((PyObject *) t));    /* Note: always
                                                           malloc((strlen + 1)*
                                                           sizeof(char))
                                                           because strlen does
                                                           not include null
                                                           terminator. */
    /* Unpack protein name and strcpy to prevent tampering. */
    protein_string = malloc((PyString_Size((PyObject *) protein) + 1) *
                            sizeof(char));
    strcpy(protein_string, PyString_AsString((PyObject *) protein));
    /*
     * 
     * Unpack window dictionary and obtain number of cycles.
     *
     * dict_pos tracks dictionary position in PyDict_Next.
     * dict_size is the number of key: value pairs in the windows dictionary.
     * unpack_acid and unpack_cycles are temporary variables for unpacking.
     *
     */
    Py_ssize_t dict_pos = 0;
    Py_ssize_t dict_size = PyDict_Size((PyObject *) windows);
    acids = malloc(sizeof(char) * (dict_size + 1));    /* +1 because
                                                          PyString_AS_STRING
                                                          returns character +
                                                          null terminator. */
    PyStringObject *unpack_acid;
    PyIntObject *unpack_cycles;
    acids_iterator = acids;    /* Initialize iterator. */
    for (i = 0; i < dict_size; i++)
    {
        PyDict_Next((PyObject *) windows, &dict_pos,
                    (PyObject **) &unpack_acid, (PyObject **) &unpack_cycles);
        strcpy(acids_iterator, PyString_AS_STRING(unpack_acid));
        ++acids_iterator;
        if (i == 0)
            cycles = PyInt_AS_LONG(unpack_cycles);
    }

    /*
     *
     * Create instance of SignalTrie and its method to ensure their persistence
     * through this function.
     *
     */
    /* No need to decref return_trie as it gets returned. */

    /*************************************************************************/
    /* Initialize C trie. ****************************************************/
    signal_trie = malloc(sizeof(node));
    signal_trie->position = -1;
    signal_trie->acid = 'z';
    signal_trie->descendants = malloc(sizeof(node) * 10);
    signal_trie->num_descendants = 0L;
    signal_trie->d_size = 10L;
    signal_trie->counts = malloc(sizeof(source_count) * 10);
    signal_trie->num_counts = 0;
    signal_trie->c_size = 10;

    /*************************************************************************/
    /* Seed Merseinne Twister. ***********************************************/
    /* TODO: get clock_gettime to work for better random seeding */
    /*struct timespec seeder;
    clock_gettime(CLOCK_REALTIME, &seeder);
    init_gen_rand(random_seed + seeder.tv_nsec);*/
    init_gen_rand(random_seed);
    
    /*************************************************************************/
    /* Initialize observations arrays ****************************************/
     
    /* First step is to count the number of observation blocks to create. */
    num_obs = 0;
    num_head_obs = 0;
    for (i = 0; i < strlen(acids); i++)
    {
        for (j = 0; j < strlen(head); j++)
        {
            if (acids[i] == head[j])
            {
                ++num_obs;
                ++num_head_obs;
            }
        }
        for (j = 0; j < strlen(tail); j++)
        {
            if (acids[i] == tail[j])
                ++num_obs;
        }
    }
    observations = malloc(num_obs * sizeof(acid_observation));
    observations_template = malloc(num_obs * sizeof(acid_observation));
    obs_iter = observations;
    obs_template_iter = observations_template;
    /*
     *
     * Note: subsequent code assumes that observations is already ordered by
     * i_position. This means either initialize in the correct order or sort.
     *
     */
    for (i = 0; i < strlen(head); i++)
    {
        for (j = 0; j < strlen(acids); j++)
        {
            if (head[i] == acids[j])
            {
                obs_template_iter->i_position = i + 1;
                obs_template_iter->i_acid = acids[j];
                ++obs_template_iter;
                break;
            }
        }
    }
    for (i = 0; i < strlen(tail); i++)
    {
        for (j = 0; j < strlen(acids); j++)
        {
            if (tail[i] == acids[j])
            {
                obs_template_iter->i_position = -1;
                obs_template_iter->i_acid = acids[j];
                ++obs_template_iter;
                break;
            }
        }
    }

    /* Initialize nonempty observations array of pointers. */
    nonempty_observations = malloc(sizeof(acid_observation *) * num_obs);


    /*************************************************************************/
    /* Main simulation loop. *************************************************/
    for (s = 0; s < sample_size; s++)
    {
        /* Initialize observations' outputs to their ideal configurations. */
        obs_iter = observations;
        obs_template_iter = observations_template;
        for (i = 0; i < num_obs; i++)
        {
            obs_iter->i_position = obs_template_iter->i_position;
            obs_iter->o_position = obs_template_iter->i_position;
            obs_iter->i_acid = obs_template_iter->i_acid;
            obs_iter->o_acid = obs_template_iter->i_acid;
            ++obs_iter;
            ++obs_template_iter;
        }
        /*
         *
         * Remove acids from head and tail based on u. Assume x is not a
         * character ever found in proteome aa sequences -- it is used to
         * bookmark those acids whose fluors failed.
         *
         */
        obs_iter = observations;
        for (i = 0; i < num_obs; i++)
        {
            random_point = genrand_real1();
            if (random_point <= u)
                obs_iter->o_acid = 'x';
            ++obs_iter;
        }
        /*
         * Simulate Edman failure.
         *
         * prior_pos stores the initial position of the prior amino acid.
         * d stores the distance between successive amino acids in a peptide.
         * e stores the number of failures between two successive amino acids.
         * cumulative_e stores the total number of failures since the start.
         * prior_accumulator is used to prevent iterating through an
         *     asymptoticaly decreasing cumulative probability distribution
         *     indefinetly.
         * accumulator_precision determines lower bound of acceptable increase
         *     in prior_accumulator.
         *
         */
        int prior_pos;
        int cumulative_e = 0;
        int d, e;
        float prior_accumulator;
        const float accumulator_precision = 0.0000001F;
        obs_iter = observations;
        for (i = 0; i < num_head_obs; i++)
        {
            if (i == 0)
                d = obs_iter->i_position;
            else
                d = obs_iter->i_position - prior_pos; 
            prior_pos = obs_iter->i_position;
            e = 0;
            accumulator = 0;
            prior_accumulator = -1;
            random_point = genrand_real1();
            while (accumulator - prior_accumulator > accumulator_precision)
            {
                prior_accumulator = accumulator;
                /*
                 *
                 * gsl_ran_binomial_pdf(k, p, n) is binomial distribution
                 * probability of choosing k items out of n with independant
                 * probability p, which is (n choose k) * p^k * q^(n - k).
                 *
                 * The probability of d successes and e failures between two
                 * successive amino acids is
                 * (d - 1 + e choose d - 1) * p^d * q^e. If we use
                 * gsl_ran_binomial_pdf(d - 1, p, d - 1 + e) this function
                 * computes (d - 1 + e choose d - 1) * p^(d - 1) * q^e. Hence
                 * the additional multiplication by p.
                 *
                 */
                accumulator += (float) (p * gsl_ran_binomial_pdf(d - 1, p,
                                                                 d - 1 + e));
                if (accumulator >= random_point)
                    break;
                else
                    e += 1;
            }
            cumulative_e += e;
            obs_iter->o_position = (obs_iter->i_position + cumulative_e);
            ++obs_iter;
        }
        /* Simulate photobleaching. First loop for heads, second for tails. */
        obs_iter = observations;
        for (i = 0; i < num_head_obs; i++)
        {
            random_point = genrand_real1();
            accumulator = 0;
            exposures = ((cycles < obs_iter->o_position) ?
                         cycles + 1 :  obs_iter->o_position);
            for (j = 0; j < exposures; j++)
            {
                accumulator += exp(-b * j);
                if (accumulator * (1 - exp(-b)) >= random_point)
                {
                    obs_iter->o_position = j + 1;
                    break;
                }
            }
            ++obs_iter;
        }
        exposures = cycles;
        for (i = num_head_obs; i < num_obs; i++)
        {
            random_point = genrand_real1();
            accumulator = 0;
            for (j = 0; j < exposures; j++)
            {
                accumulator += exp(-b * j);
                if (accumulator * (1 - exp(-b)) >= random_point)
                {
                    obs_iter->o_position = j + 1;
                    break;
                }
            }
            ++obs_iter;
        }
        /* Eliminate all obsrevations that cannot be observed within cycles. */
        /*obs_iter = observations;
        for (i = 0; i < num_obs; i++)
        {
            if (obs_iter->o_position > cycles)
                 obs_iter->o_acid = 'x';
            ++obs_iter;
        }*/
        /* Sort observations by position. */
        qsort(observations, num_obs, sizeof(acid_observation),
              CompareAcidObservations);
        /* This sample's simulation complete. Propagate into C signal_trie. */
        /* Count number of nonempty acid_observations. */
        nonempty = 0;
        obs_iter = observations;
        nonempty_iter = nonempty_observations;
        /*
         *
         * CompareAcidObservations sorts by position first, then by acid. To
         * eliminate duplicate signals, last position and acid need to be
         * tracked.
         *
         */
        char dup_acid = 'x';
        int dup_position = -1;
        for (i = 0; i < num_obs; i++)
        {
            /* Anything observed after cycles is invisible anyways. */
            if (obs_iter->o_position > cycles)
                break;
            if (obs_iter->o_position >= 0 && obs_iter->o_acid != 'x')
            {
                /* Check for dups. */
                if (obs_iter->o_position == dup_position &&
                    obs_iter->o_acid == dup_acid)
                {
                    ++obs_iter;
                    continue;
                }
                else
                {
                    dup_position = obs_iter->o_position;
                    dup_acid = obs_iter->o_acid;
                }
                ++nonempty;
                *nonempty_iter = obs_iter;
                ++nonempty_iter;
            }
            else
            {
            }
            ++obs_iter;
        }
        if (nonempty == 0)    /* Do not package empty signals. */
            continue;
        AddSignal(signal_trie, nonempty_observations, nonempty,
                  protein_string);
    }

    /*************************************************************************/
    /* Package C trie into Python. *******************************************/
    int prefix_alloc = 10;
    node **prefix = malloc(sizeof(node *) * prefix_alloc);
    int prefix_length = 0;
    PackagePyTrie(signal_trie, &prefix, prefix_length, &prefix_alloc,
                  return_trie);

    /*************************************************************************/
    /* Free allocated memory. ************************************************/
    free(head);
    free(tail);
    free(protein_string);
    free(acids);
    free(prefix);
    free(observations);
    free(observations_template);
    free(signal_trie);
    free(nonempty_observations);

    /*************************************************************************/
    /* DECREF Python objects created. ****************************************/
    /*Py_DECREF(root_graft);
    Py_DECREF(graft_function);*/
    Py_DECREF(peptide);
    Py_DECREF(protein);
    Py_DECREF(windows);
    Py_DECREF(h);
    Py_DECREF(t);
    /*Py_DECREF(return_trie);*/

    return return_trie;
}

static PyMethodDef randsiggenMethods[] = {
    {"random_signal", RandomSignal, METH_VARARGS, random_signal_docstring},
    {NULL, NULL, 0, NULL}
};

PyMODINIT_FUNC
initrandsiggen(void) {
    Py_InitModule("randsiggen", randsiggenMethods);
}
